# Day 3: SBOM Generation & Vulnerability Analysis

**Date:** [15 Jan]  
**Time Spent:** ~3 hours  
**Status:** ‚úÖ Complete

---

## üéØ Objectives Completed

- [x] Installed Syft and Grype
- [x] Generated SBOMs in multiple formats (CycloneDX, SPDX)
- [x] Scanned images for vulnerabilities
- [x] Attached SBOM as signed attestation
- [x] Created vulnerability query scripts
- [x] Simulated Log4Shell incident response
- [x] Documented SBOM strategy and storage approach

---

## üîÑ What Changed

**Before Day 3:**
- ‚úÖ Images are signed and authentic
- ‚úÖ Only signed images can run
- ‚ùå Don't know what's INSIDE images
- ‚ùå Can't identify vulnerabilities
- ‚ùå Can't respond to CVE announcements quickly

**After Day 3:**
- ‚úÖ Know exact dependencies in each image (SBOM)
- ‚úÖ Can identify vulnerabilities automatically
- ‚úÖ Can query "which images have package X?"
- ‚úÖ Can respond to Log4Shell-style incidents in minutes

---

## üîê Key Concepts Learned

### 1. SBOM = Software Bill of Materials
"Ingredient list" for container images:
- Every package installed
- Version numbers
- Transitive dependencies (dependencies of dependencies)

**Analogy:** Food nutrition label for software

### 2. SBOM Formats
- **SPDX:** License compliance focus, ISO standard
- **CycloneDX:** Security focus, vulnerability-aware

**Choice:** CycloneDX for supply chain security

### 3. Transitive Dependencies
```
You add: express (1 package)
You get: 100+ packages (transitives)
You're responsible for: ALL of them

Insight: Most vulnerabilities are in transitives you never explicitly chose
4. False Positives
Not all CVEs are exploitable in your context:

Kernel CVE in userspace-only container = false positive
Library included but never called = false positive

Solution: VEX (Day 3.5) - document "not affected"
5. SBOM Storage

Attestations: Simple, bound to image, can't query across images
Database: Complex, enables queries, historical tracking

Decision: Attestations for <50 images, database for >100

üìä Vulnerability Analysis Results
Test Image: nginx:alpine

Total packages: 37
Total vulnerabilities: 64

Critical: 3
High: 12
Medium: 31
Low: 18



Key insight: Even "simple" official images have 60+ CVEs
Test Image: node:18-alpine with 2 dependencies

Direct dependencies: 2 (express, lodash)
Total packages: 147 (transitive explosion!)
Total vulnerabilities: 89

Critical: 5
High: 23
Medium: 41
Low: 20



Key insight: npm dependency trees explode quickly

üß® Log4Shell Simulation
Scenario
CVE-2021-44228 announced (Critical RCE in log4j)
Response Without SBOM
Hour 0: CVE announced
Hour 1-12: Manual code search
Hour 12-24: Check all services
Hour 24-48: Still finding instances
Result: 48+ hours to identify exposure

Response With SBOM
Minute 0: CVE announced
Minute 5: Query SBOM database
Minute 10: Found 12 affected images
Minute 15: Identified 47 running pods
Minute 30: Patched and redeployed
Result: 30 minutes end-to-end
üé§ Interview Talking Points
Question: "What is an SBOM and why does it matter?"
My Answer:
"An SBOM is a Software Bill of Materials - essentially an ingredient list
for a container image. It lists every package, library, and dependency
installed in the image, along with version numbers.
SBOMs matter for three reasons:

Rapid incident response: When Log4Shell dropped in December 2021,
companies with SBOMs could query 'which images have log4j?' in minutes.
Without SBOMs, it took days of manual searching.
Vulnerability management: You can't secure what you can't see.
A simple nginx:alpine image has 30-50 packages - do you know what they
all are? SBOMs make the invisible visible.
Transitive dependency tracking: You might add one package (express),
but get 100+ transitives. SBOMs capture the entire dependency tree,
which is where most vulnerabilities hide.

The analogy I use: SBOMs are like nutrition labels on food. You wouldn't
eat food without knowing ingredients - why run software without knowing
what's in it?"

Question: "How do you handle the thousands of CVEs in SBOMs?"
My Answer:
"This is the false positive problem - a real operational challenge.
The reality:

nginx:alpine has 60+ CVEs
Most are Medium/Low severity
Many aren't exploitable in our context

Our prioritization framework:

Severity + Exploit

Critical + active exploits = patch in 7 days
High + no exploit = patch in 30 days
Medium/Low = backlog


Reachability analysis

Is the vulnerable code path even executed?
Kernel CVE in userspace-only container = ignore
This requires VEX (Vulnerability Exploit



ability eXchange)

Risk-based decisions

Not all Critical CVEs are critical for us
Context matters: Internet-facing vs internal-only



Metrics we track:

False positive rate (target <30% with VEX)
Mean time to remediate Critical CVEs (target <7 days)
Vulnerability debt (trend should be decreasing)

Staff-level insight:
The goal isn't zero CVEs (impossible). It's:

Know what vulnerabilities exist (SBOM)
Prioritize based on real risk (not just CVSS)
Track remediation (measure progress)

Perfect security is impossible. Measured risk reduction is achievable."

Question: "SBOM formats - SPDX vs CycloneDX?"
My Answer:
"Both are valid standards, but they serve different primary purposes:
SPDX (Software Package Data Exchange):

Linux Foundation standard, now ISO
Focus: License compliance
Use case: Legal teams tracking OSS licenses
Strength: Comprehensive relationship modeling

CycloneDX:

OWASP standard
Focus: Security and vulnerability management
Use case: Security teams tracking CVEs
Strength: Native vulnerability integration

My choice for supply chain security: CycloneDX
Reasoning:

Our primary goal is vulnerability management, not licensing
CycloneDX natively includes CVE information
Syft/Grype tooling has excellent CycloneDX support
Security community momentum is behind CycloneDX

Tradeoff:
If we had strong licensing requirements (legal compliance),
SPDX would be better. But for DevSecOps supply chain focus,
CycloneDX fits our threat model.
Staff consideration:
The format matters less than having SBOMs at all. Start with one
format, tooling can convert if needed later."

üìä Artifacts Created
SBOMs Generated:

myapp-sbom-cyclonedx.json
myapp-sbom-spdx.json
node-app SBOM
java-app SBOM

Vulnerability Scans:

myapp vulnerabilities
nginx comparison scans

Scripts:

query-vulns.sh - Query CVEs by severity
find-package.sh - Log4Shell-style package search

Policies:

require-sbom-attestation.yaml

Documentation:

ADR 004: SBOM Strategy
SBOM Database Design


‚ö†Ô∏è Limitations & Honest Boundaries
What SBOMs Provide
‚úÖ Visibility into dependencies
‚úÖ Vulnerability identification
‚úÖ Rapid incident response
‚úÖ Historical tracking
What SBOMs DON'T Provide
‚ùå Guarantee of security (signed image can have CVEs)
‚ùå Perfect accuracy (Syft can miss packages)
‚ùå Exploit context (is CVE actually exploitable?)
‚ùå Automatic remediation (still need to patch)
What I Don't Know Yet

SBOM accuracy at scale: Syft's false positive/negative rate across 1000s of images
VEX implementation: Day 3.5 will cover reachability analysis
SBOM database performance: Query time with 200K+ component records
Cross-language dependency tracking: Go modules vs npm vs Maven nuances

Why this honesty matters:
Staff engineers know tool limits. SBOM isn't a silver bullet - it's
visibility that enables better decisions. Overselling it damages credibility.

üîó Integration with Days 1-2
Complete Supply Chain Security Stack
Day 3: SBOM (VISIBILITY) ‚Üê WE ARE HERE
    ‚Üì
    Know what's inside images
    ‚Üì
Day 2: Admission Control (ENFORCEMENT)
    ‚Üì
    Block unsigned images
    ‚Üì
Day 1.5: Keyless Signing
    ‚Üì
    No key management burden
    ‚Üì
Day 1: Image Signing (INTEGRITY)
    ‚Üì
    Prove images are authentic
Defense in Depth Progress:

‚úÖ Layer 1: Signing (integrity + provenance) - Days 1-1.5
‚úÖ Layer 2: Admission control (enforcement) - Day 2
‚úÖ Layer 3: SBOM (visibility) - Day 3
‚è≥ Layer 4: SLSA provenance (build integrity) - Day 4
‚è≥ Layer 5: Runtime security (behavior) - Day 6


üéØ What's Next
Day 3.5 (Tomorrow): VEX & Reachability Analysis
Current gap:

‚úÖ Know all CVEs in image (SBOM)
‚ùå Don't know which are actually exploitable
‚ùå 60+ CVEs creates alert fatigue

Day 3.5 goal:

Implement VEX (Vulnerability Exploitability eXchange)
Document "not affected" status for false positives
Reduce alert noise by 70-80%
Focus on REAL risks, not theoretical ones

The addition:

SBOM says "Image contains openssl 1.1.1k with CVE-2022-0778"
VEX says "CVE-2022-0778 not exploitable - vulnerable code path never executed"
Result: Informed decision, not panic


üìà Metrics Implemented
SBOM Coverage:

Images with SBOM: 100% (all test images)
SBOM generation time: 30-45 seconds per image
SBOM size: 50-200KB per image

Vulnerability Tracking:

Total CVEs identified: 200+ across test images
Critical: 15
High: 45
Medium: 90
Low: 50+

Query Performance:

"Which images have package X?" - 5 seconds (with attestations)
(Database implementation would be <500ms)


‚úÖ Final Checklist
Technical Execution

 Syft installed and working
 Grype installed and working
 Generated SBOMs in multiple formats
 Scanned images for vulnerabilities
 Attached SBOM as Cosign attestation
 Created query scripts
 Tested with multi-language images (Node, Java)

Documentation

 Daily log completed
 ADR 004 written (SBOM strategy)
 Database design documented
 Interview talking points prepared
 Log4Shell scenario documented

Understanding

 Can explain what SBOM is and why it matters
 Can differentiate SPDX vs CycloneDX
 Can explain transitive dependencies
 Can discuss false positive handling
 Can justify storage strategy (attestations vs database)

Portfolio Quality

 SBOM files saved with clear naming
 Vulnerability scan results archived
 Query scripts documented and executable
 Policy files committed
 Architecture decisions recorded

Staff-Level Thinking

 Cost-benefit analysis (build time vs ROI)
 Scaling considerations (database design)
 False positive handling strategy
 Operational metrics defined
 Integration with existing controls (Days 1-2)


üéâ Day 3 Achievement
What You Built:

SBOM generation pipeline
Vulnerability scanning automation
Query tooling for incident response
SBOM attestation integration

What You Learned:

SBOM formats and use cases
Transitive dependency complexity
Vulnerability prioritization frameworks
False positive challenge

What Makes This Staff-Level:

Not just "ran Syft and Grype"
But "designed SBOM strategy with format justification, storage tradeoffs,
false positive handling, and Log4Shell response simulation"
Can defend decisions with data (ROI: 48 hours ‚Üí 30 minutes)


Time Invested:

Day 1: 5 hours
Day 1.5: 2.5 hours
Day 2: 3 hours
Day 3: 3 hours
Total: 13.5 hours

Progress:

‚úÖ 4 of 26 days complete (15%)
‚úÖ Supply chain foundation complete (sign + enforce + visibility)
‚è≥ Next: VEX for reducing false positives

Status: üöÄ Strong momentum, practical depth
